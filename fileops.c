/* Use newer version of FUSE API. */
#define FUSE_USE_VERSION 26
#include <fuse.h>

#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>

#include "entry.h"
#include "fileops.h"
#include "globals.h"
#include "log.h"

#define BIT(n) (1UL << (n))
#define R BIT(2)
#define W BIT(1)
#define X BIT(0)

#define RIGHTS_MASK 0x3

/* Note: doing a linear search on the entries array is not an efficient way of
 * implementing a file system that will be under heavy load, but we assume that
 * there will be few entries in the file system and these will not be accessed
 * frequently.
 */

static int is_root(const char *path) {
    return !strcmp("/", path);
}

static entry_t *find_entry(const char *path) {
    if (path[0] != '/') {
        /* We were passed a path outside this mount point (?) */
        return NULL;
    }

    int i;
    for (i = 0; i < entries_sz; ++i) {
        if (!strcmp(path + 1, entries[i]->path)) {
            return entries[i];
        }
    }
    return NULL;
}

static unsigned int access_rights(entry_t *entry) {
    struct fuse_context *context = fuse_get_context();
    unsigned int rights;

    if (context->uid == uid) {
        rights = (entry->u_r ? R : 0)
            | (entry->u_w ? W : 0)
            | (entry->u_x ? X : 0);
    } else if (context->gid == gid) {
        rights = (entry->g_r ? R : 0)
            | (entry->g_w ? W : 0)
            | (entry->g_x ? X : 0);
    } else {
        rights = (entry->o_r ? R : 0)
            | (entry->o_w ? W : 0)
            | (entry->o_x ? X : 0);
    }
    return rights;
}

static void exec_destroy(void *private_data) {
    log_close();
}

static int exec_getattr(const char *path, struct stat *stbuf) {
    assert(stbuf != NULL);

    /* stbuf->st_dev is ignored. */
    /* stbuf->st_ino is ignored. */
    stbuf->st_uid = uid;
    stbuf->st_gid = gid;
    /* stbuf-st_rdev is irrelevant. */
    /* stbuf->st_blksize is ignored. */
    /* stbuf->st_blocks is ignored. */
    stbuf->st_atime = stbuf->st_mtime = stbuf->st_ctime = time(NULL);

    if (is_root(path)) {
        stbuf->st_mode = S_IFDIR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
        stbuf->st_size = 0;
        stbuf->st_nlink = 1;
    } else {
        entry_t *e = find_entry(path);
        if (e == NULL) {
            return -ENOENT;
        }

        /* It would be nice to mark entries as FIFOs (S_IFIFO), but
         * irritatingly the kernel doesn't call FUSE handlers for FIFOs so we
         * never get read/write calls. To further complicate matters some
         * programs like cat attempt to be clever and stat the size of a file
         * to see how much they should read. To get around this we need to set
         * a reasonably large file size.
         */
        stbuf->st_mode = S_IFREG
            | (e->u_r ? S_IRUSR : 0)
            | (e->u_w ? S_IWUSR : 0)
            | (e->u_x ? S_IXUSR : 0)
            | (e->g_r ? S_IRGRP : 0)
            | (e->g_w ? S_IWGRP : 0)
            | (e->g_x ? S_IXGRP : 0)
            | (e->o_r ? S_IROTH : 0)
            | (e->o_w ? S_IWOTH : 0)
            | (e->o_x ? S_IXOTH : 0);
        stbuf->st_size = 1024;
        stbuf->st_nlink = 1;
    }

    return 0;
}

static int exec_open(const char *path, struct fuse_file_info *fi) {
    entry_t *e = find_entry(path);
    if (e == NULL) {
        return -ENOENT;
    }

    assert(fi != NULL);
    unsigned int entry_rights = access_rights(e);
    unsigned int rights = fi->flags & RIGHTS_MASK;

    if (((rights == O_RDONLY || rights == O_RDWR) && !(entry_rights & R)) ||
        ((rights == O_WRONLY || rights == O_RDWR) && !(entry_rights & W))) {
        return -EACCES;
    }

    /* TODO: rw pipes. */
    fi->fh = (uint64_t)popen(e->command, rights == O_RDONLY ? "r" : "w");
    if (fi->fh == 0) {
        return -EBADF;
    }

    return 0;
}

static int exec_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
    entry_t *e = find_entry(path);
    if (e == NULL) {
        return -ENOENT;
    }

    assert(fi != NULL);
    assert(fi->fh != 0);
    size_t sz = read(fi->fh, buf, size);
    return sz;
}

static int exec_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {
    if (!is_root(path)) {
        /* Don't support subdirectories. */
        return -EBADF;
    }

    int i;
    for (i = offset; i < entries_sz; ++i) {
        if (filler(buf, entries[i]->path, NULL, i + 1) != 0) {
            return 0;
        }
    }
    return 0;
}

static int exec_release(const char *path, struct fuse_file_info *fi) {
    assert(is_root(path) || find_entry(path) != NULL);
    assert(fi != NULL);
    assert(fi->fh != 0);
    (void)pclose((FILE*)fi->fh);
    return 0;
}

struct fuse_operations ops = {
    .destroy = &exec_destroy,
    .getattr = &exec_getattr,
    .open = &exec_open,
    .read = &exec_read,
    .readdir = &exec_readdir,
    .release = &exec_release,
};
